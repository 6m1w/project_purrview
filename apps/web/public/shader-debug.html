<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Scanline Shader Debug</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #f4f4f0; overflow: hidden; font-family: monospace; }
  canvas { display: block; width: 100vw; height: 100vh; }
  #controls {
    position: fixed; top: 10px; right: 10px; z-index: 100;
    background: rgba(0,0,0,0.85); color: #fff; padding: 16px;
    border-radius: 8px; font-size: 12px; min-width: 280px;
    max-height: 90vh; overflow-y: auto;
  }
  #controls h3 { margin-bottom: 12px; font-size: 14px; color: #0f0; }
  .ctrl { margin-bottom: 10px; }
  .ctrl label { display: flex; justify-content: space-between; margin-bottom: 2px; }
  .ctrl input[type="range"] { width: 100%; }
  .ctrl .val { color: #0f0; font-weight: bold; }
  .section { border-top: 1px solid #444; padding-top: 10px; margin-top: 10px; }
  .section-title { color: #888; font-size: 11px; text-transform: uppercase; margin-bottom: 8px; }
  .toggle { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; }
  .toggle input { width: 16px; height: 16px; }
  #export-btn {
    width: 100%; padding: 8px; margin-top: 12px;
    background: #0f0; color: #000; border: none; font-weight: bold;
    cursor: pointer; border-radius: 4px; font-family: monospace;
  }
  #export-btn:hover { background: #0c0; }
  #export-output {
    margin-top: 8px; padding: 8px; background: #111;
    font-size: 10px; color: #0f0; white-space: pre; display: none;
    border-radius: 4px; max-height: 120px; overflow-y: auto;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>

<div id="controls">
  <h3>Scanline Shader Debug</h3>

  <div class="section">
    <div class="section-title">Video Source</div>
    <div class="ctrl">
      <select id="videoSelect" style="width:100%;padding:4px;background:#222;color:#0f0;border:1px solid #444;font-family:monospace;">
        <option value="/majiang_nobg.webm" selected>majiang (麻酱)</option>
        <option value="/songhua_nobg.webm">songhua (松花)</option>
        <option value="/xiaoman_nobg.webm">xiaoman (小慢)</option>
      </select>
    </div>
  </div>

  <div class="section">
    <div class="section-title">Render Mode</div>
    <div class="toggle">
      <input type="checkbox" id="variableWidth" checked>
      <label for="variableWidth">Variable Line Width (vs Binary Threshold)</label>
    </div>
    <div class="toggle">
      <input type="checkbox" id="coverMode" checked>
      <label for="coverMode">Cover Mode (vs Contain)</label>
    </div>
    <div class="toggle">
      <input type="checkbox" id="bgScanlines" checked>
      <label for="bgScanlines">Background Scanlines</label>
    </div>
  </div>

  <div class="section">
    <div class="section-title">Scanlines</div>
    <div class="ctrl">
      <label>Line Density (gap px) <span class="val" id="v_density">4</span></label>
      <input type="range" id="lineDensity" min="2" max="20" step="0.5" value="4">
    </div>
    <div class="ctrl">
      <label>Line Width Ratio <span class="val" id="v_widthRatio">0.42</span></label>
      <input type="range" id="widthRatio" min="0.1" max="0.95" step="0.01" value="0.42">
    </div>
    <div class="ctrl">
      <label>Threshold (binary mode) <span class="val" id="v_threshold">0.55</span></label>
      <input type="range" id="threshold" min="0.1" max="0.95" step="0.01" value="0.55">
    </div>
  </div>

  <div class="section">
    <div class="section-title">Glitch / Jitter</div>
    <div class="ctrl">
      <label>Jitter (px) <span class="val" id="v_jitter">15</span></label>
      <input type="range" id="jitter" min="0" max="80" step="1" value="15">
    </div>
    <div class="ctrl">
      <label>Jitter Speed <span class="val" id="v_jitterSpeed">18</span></label>
      <input type="range" id="jitterSpeed" min="1" max="60" step="1" value="18">
    </div>
  </div>

  <div class="section">
    <div class="section-title">Position</div>
    <div class="ctrl">
      <label>Offset X <span class="val" id="v_offsetX">0.00</span></label>
      <input type="range" id="offsetX" min="-0.4" max="0.4" step="0.01" value="0">
    </div>
    <div class="ctrl">
      <label>Offset Y <span class="val" id="v_offsetY">0.00</span></label>
      <input type="range" id="offsetY" min="-0.4" max="0.4" step="0.01" value="0">
    </div>
    <div class="ctrl">
      <label>Zoom <span class="val" id="v_zoom">1.00</span></label>
      <input type="range" id="zoom" min="0.5" max="2.0" step="0.05" value="1.0">
    </div>
  </div>

  <div class="section">
    <div class="section-title">Cleanup</div>
    <div class="ctrl">
      <label>Alpha Threshold <span class="val" id="v_alphaThreshold">0.50</span></label>
      <input type="range" id="alphaThreshold" min="0.1" max="0.9" step="0.05" value="0.5">
    </div>
    <div class="ctrl">
      <label>Min Darkness <span class="val" id="v_minDarkness">0.08</span></label>
      <input type="range" id="minDarkness" min="0" max="0.3" step="0.01" value="0.08">
    </div>
    <div class="ctrl">
      <label>Crop Left <span class="val" id="v_cropLeft">0.00</span></label>
      <input type="range" id="cropLeft" min="0" max="0.5" step="0.01" value="0">
    </div>
  </div>

  <div class="section">
    <div class="section-title">Colors</div>
    <div class="ctrl">
      <label>FG Brightness <span class="val" id="v_fgBright">0.07</span></label>
      <input type="range" id="fgBright" min="0" max="0.3" step="0.01" value="0.07">
    </div>
    <div class="ctrl">
      <label>BG Brightness <span class="val" id="v_bgBright">0.96</span></label>
      <input type="range" id="bgBright" min="0.7" max="1.0" step="0.01" value="0.96">
    </div>
    <div class="ctrl">
      <label>BG Scanline Opacity <span class="val" id="v_bgLineOpacity">0.93</span></label>
      <input type="range" id="bgLineOpacity" min="0.8" max="1.0" step="0.01" value="0.93">
    </div>
  </div>

  <button id="export-btn">Export Config</button>
  <pre id="export-output"></pre>
</div>

<script>
// Shader sources
const VERT = `
attribute vec2 a_pos;
varying vec2 v_uv;
void main() {
  v_uv = a_pos * 0.5 + 0.5;
  gl_Position = vec4(a_pos, 0.0, 1.0);
}`;

const FRAG = `
precision mediump float;
varying vec2 v_uv;
uniform sampler2D u_tex;
uniform vec2 u_resolution;
uniform vec2 u_videoSize;
uniform float u_time;
uniform float u_lineDensity;
uniform float u_widthRatio;
uniform float u_threshold;
uniform float u_jitterPx;
uniform float u_jitterSpeed;
uniform float u_variableWidth;
uniform float u_coverMode;
uniform float u_bgScanlines;
uniform float u_offsetX;
uniform float u_offsetY;
uniform float u_zoom;
uniform float u_alphaThreshold;
uniform float u_minDarkness;
uniform float u_cropLeft;
uniform vec3 u_fg;
uniform vec3 u_bg;
uniform float u_bgLineOpacity;

float hash(float n) {
  return fract(sin(n) * 43758.5453123);
}

void main() {
  vec2 uv = v_uv;
  float yPx = uv.y * u_resolution.y;

  float canvasAspect = u_resolution.x / u_resolution.y;
  float videoAspect = u_videoSize.x / u_videoSize.y;
  vec2 sampleUV = uv;

  if (u_coverMode > 0.5) {
    // Cover mode: fill canvas, crop excess
    if (videoAspect > canvasAspect) {
      float scale = canvasAspect / videoAspect;
      sampleUV.x = (uv.x - 0.5) * scale + 0.5;
    } else {
      float scale = videoAspect / canvasAspect;
      sampleUV.y = (uv.y - 0.5) * scale + 0.5;
    }
  } else {
    // Contain mode: fit entire video, may have bars
    if (videoAspect > canvasAspect) {
      float scale = videoAspect / canvasAspect;
      sampleUV.y = (uv.y - 0.5) * scale + 0.5;
    } else {
      float scale = canvasAspect / videoAspect;
      sampleUV.x = (uv.x - 0.5) * scale + 0.5;
    }
  }

  // Zoom and offset
  sampleUV = (sampleUV - 0.5) / u_zoom + 0.5;
  sampleUV.x += u_offsetX;
  sampleUV.y += u_offsetY;

  // Scanline row calculation
  float lineGapPx = max(2.0, u_lineDensity);
  float row = floor(yPx / lineGapPx);
  float local = mod(yPx, lineGapPx);

  // Horizontal jitter
  float jitterSeed = row * 19.19 + floor(u_time * u_jitterSpeed);
  float n = hash(jitterSeed) * 2.0 - 1.0;
  float wobble = sin(u_time * 8.0 + row * 0.45) * 0.5;
  float jitterNorm = (n * 0.7 + wobble * 0.3) * (u_jitterPx / u_resolution.x);
  sampleUV.x += jitterNorm;

  // Out of bounds -> background
  if (sampleUV.x < 0.0 || sampleUV.x > 1.0 || sampleUV.y < 0.0 || sampleUV.y > 1.0) {
    if (u_bgScanlines > 0.5) {
      float bgLineWidth = 0.7;
      if (local <= bgLineWidth) {
        gl_FragColor = vec4(u_bg * u_bgLineOpacity, 1.0);
      } else {
        gl_FragColor = vec4(u_bg, 1.0);
      }
    } else {
      gl_FragColor = vec4(u_bg, 1.0);
    }
    return;
  }

  // Crop left edge (removes black border artifacts)
  if (u_cropLeft > 0.0 && sampleUV.x < u_cropLeft) {
    if (u_bgScanlines > 0.5) {
      float bgLineWidth = 0.7;
      if (local <= bgLineWidth) {
        gl_FragColor = vec4(u_bg * u_bgLineOpacity, 1.0);
      } else {
        gl_FragColor = vec4(u_bg, 1.0);
      }
    } else {
      gl_FragColor = vec4(u_bg, 1.0);
    }
    return;
  }

  sampleUV = clamp(sampleUV, 0.0, 1.0);
  vec4 c = texture2D(u_tex, sampleUV);
  float luma = dot(c.rgb, vec3(0.2126, 0.7152, 0.0722));
  float darkness = 1.0 - luma;

  // Transparent or too-bright area -> background
  if (c.a < u_alphaThreshold || darkness < u_minDarkness) {
    if (u_bgScanlines > 0.5) {
      float bgLineWidth = 0.7;
      if (local <= bgLineWidth) {
        gl_FragColor = vec4(u_bg * u_bgLineOpacity, 1.0);
      } else {
        gl_FragColor = vec4(u_bg, 1.0);
      }
    } else {
      gl_FragColor = vec4(u_bg, 1.0);
    }
    return;
  }

  if (u_variableWidth > 0.5) {
    // Variable line width mode: darkness controls line thickness
    float maxLineWidth = lineGapPx * u_widthRatio;
    float lineWidth = max(0.5, darkness * maxLineWidth);
    if (local > lineWidth) {
      gl_FragColor = vec4(u_bg, 1.0);
      return;
    }
    gl_FragColor = vec4(u_fg, 1.0);
  } else {
    // Binary threshold mode: fixed line width, B/W threshold
    float lineWidth = max(1.0, lineGapPx * u_widthRatio);
    if (local > lineWidth) {
      gl_FragColor = vec4(u_bg, 1.0);
      return;
    }
    float bw = step(u_threshold, luma);
    vec3 outColor = mix(u_fg, u_bg, bw);
    gl_FragColor = vec4(outColor, 1.0);
  }
}`;

// Init
const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl', { alpha: false, antialias: false });

function compileShader(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(s));
    return null;
  }
  return s;
}

const prog = gl.createProgram();
gl.attachShader(prog, compileShader(gl.VERTEX_SHADER, VERT));
gl.attachShader(prog, compileShader(gl.FRAGMENT_SHADER, FRAG));
gl.linkProgram(prog);
gl.useProgram(prog);

// Fullscreen quad
const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
const aPos = gl.getAttribLocation(prog, 'a_pos');
gl.enableVertexAttribArray(aPos);
gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

// Uniforms
const loc = {};
['u_tex','u_resolution','u_videoSize','u_time','u_lineDensity','u_widthRatio',
 'u_threshold','u_jitterPx','u_jitterSpeed','u_variableWidth','u_coverMode',
 'u_bgScanlines','u_offsetX','u_offsetY','u_zoom','u_alphaThreshold','u_minDarkness',
 'u_cropLeft','u_fg','u_bg','u_bgLineOpacity'
].forEach(name => loc[name] = gl.getUniformLocation(prog, name));

// Texture
const tex = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, tex);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
gl.uniform1i(loc.u_tex, 0);

// Video
const video = document.createElement('video');
video.src = '/majiang_nobg.webm';
video.autoplay = true;
video.loop = true;
video.muted = true;
video.playsInline = true;
video.crossOrigin = 'anonymous';
video.play().catch(() => {});
document.body.addEventListener('click', () => { if (video.paused) video.play(); });

// Video source switcher
document.getElementById('videoSelect').addEventListener('change', (e) => {
  video.src = e.target.value;
  video.load();
  video.play().catch(() => {});
});

// Controls binding
const sliders = {};
['lineDensity','widthRatio','threshold','jitter','jitterSpeed',
 'offsetX','offsetY','zoom','alphaThreshold','minDarkness','cropLeft','fgBright','bgBright','bgLineOpacity'
].forEach(id => {
  const el = document.getElementById(id);
  const valEl = document.getElementById('v_' + id);
  sliders[id] = el;
  el.addEventListener('input', () => { valEl.textContent = parseFloat(el.value).toFixed(2); });
});

const checks = {};
['variableWidth','coverMode','bgScanlines'].forEach(id => {
  checks[id] = document.getElementById(id);
});

// Export
document.getElementById('export-btn').addEventListener('click', () => {
  const out = document.getElementById('export-output');
  const cfg = {
    video: document.getElementById('videoSelect').value,
    mode: checks.variableWidth.checked ? 'variableWidth' : 'binaryThreshold',
    cover: checks.coverMode.checked,
    bgScanlines: checks.bgScanlines.checked,
    lineDensity: parseFloat(sliders.lineDensity.value),
    widthRatio: parseFloat(sliders.widthRatio.value),
    threshold: parseFloat(sliders.threshold.value),
    jitter: parseFloat(sliders.jitter.value),
    jitterSpeed: parseFloat(sliders.jitterSpeed.value),
    offsetX: parseFloat(sliders.offsetX.value),
    offsetY: parseFloat(sliders.offsetY.value),
    zoom: parseFloat(sliders.zoom.value),
    alphaThreshold: parseFloat(sliders.alphaThreshold.value),
    minDarkness: parseFloat(sliders.minDarkness.value),
    cropLeft: parseFloat(sliders.cropLeft.value),
    fgBright: parseFloat(sliders.fgBright.value),
    bgBright: parseFloat(sliders.bgBright.value),
    bgLineOpacity: parseFloat(sliders.bgLineOpacity.value),
  };
  out.textContent = JSON.stringify(cfg, null, 2);
  out.style.display = 'block';
  navigator.clipboard.writeText(out.textContent).catch(() => {});
});

// Resize
function resize() {
  const dpr = Math.min(devicePixelRatio || 1, 2);
  const w = Math.floor(canvas.clientWidth * dpr);
  const h = Math.floor(canvas.clientHeight * dpr);
  if (canvas.width !== w || canvas.height !== h) {
    canvas.width = w;
    canvas.height = h;
  }
  gl.viewport(0, 0, w, h);
}

// Render loop
function draw(t) {
  requestAnimationFrame(draw);
  resize();
  if (video.readyState < 2 || video.videoWidth === 0) return;

  const fg = parseFloat(sliders.fgBright.value);
  const bg = parseFloat(sliders.bgBright.value);

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);

  gl.uniform2f(loc.u_resolution, canvas.width, canvas.height);
  gl.uniform2f(loc.u_videoSize, video.videoWidth, video.videoHeight);
  gl.uniform1f(loc.u_time, t * 0.001);
  gl.uniform1f(loc.u_lineDensity, parseFloat(sliders.lineDensity.value));
  gl.uniform1f(loc.u_widthRatio, parseFloat(sliders.widthRatio.value));
  gl.uniform1f(loc.u_threshold, parseFloat(sliders.threshold.value));
  gl.uniform1f(loc.u_jitterPx, parseFloat(sliders.jitter.value));
  gl.uniform1f(loc.u_jitterSpeed, parseFloat(sliders.jitterSpeed.value));
  gl.uniform1f(loc.u_variableWidth, checks.variableWidth.checked ? 1.0 : 0.0);
  gl.uniform1f(loc.u_coverMode, checks.coverMode.checked ? 1.0 : 0.0);
  gl.uniform1f(loc.u_bgScanlines, checks.bgScanlines.checked ? 1.0 : 0.0);
  gl.uniform1f(loc.u_offsetX, parseFloat(sliders.offsetX.value));
  gl.uniform1f(loc.u_offsetY, parseFloat(sliders.offsetY.value));
  gl.uniform1f(loc.u_zoom, parseFloat(sliders.zoom.value));
  gl.uniform1f(loc.u_alphaThreshold, parseFloat(sliders.alphaThreshold.value));
  gl.uniform1f(loc.u_minDarkness, parseFloat(sliders.minDarkness.value));
  gl.uniform1f(loc.u_cropLeft, parseFloat(sliders.cropLeft.value));
  gl.uniform3f(loc.u_fg, fg, fg, fg);
  gl.uniform3f(loc.u_bg, bg, bg, bg - 0.016);
  gl.uniform1f(loc.u_bgLineOpacity, parseFloat(sliders.bgLineOpacity.value));

  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}
requestAnimationFrame(draw);
</script>
</body>
</html>
